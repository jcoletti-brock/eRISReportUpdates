#!/usr/bin/env bash
#
# answers.sh - Interactive Answer Collection
#
# Handles interactive prompting, answer collection, and answers file generation.
#

# ============================================================
# Interactive Answer Collection
# ============================================================

collect_answer() {
    # AIDEV-NOTE: Prompts user for answer based on format type
    local -n prompt=$1
    local answer=""

    # Redirect question/hint display to terminal so it's not captured by $()
    print_header "Question: ${prompt[question]}" >/dev/tty

    if [[ -n "${prompt[hint]}" ]]; then
        print_hint "  Hint: ${prompt[hint]}" >/dev/tty
    fi

    if [[ -n "${prompt[default]}" ]]; then
        print_color "$COLOR_BLUE" "  Default: ${prompt[default]}" >/dev/tty
    fi

    case "${prompt[format]}" in
        markdown-list)
            answer=$(collect_multiline_list)
            ;;
        multiline|code-block)
            answer=$(collect_multiline_text)
            ;;
        *)
            answer=$(collect_single_line "${prompt[default]}")
            ;;
    esac

    # Use default if answer is empty
    if [[ -z "$answer" && -n "${prompt[default]}" ]]; then
        # Unescape \n to actual newlines
        answer="${prompt[default]//\\n/$'\n'}"
    fi

    echo "$answer"
}

collect_single_line() {
    local default="$1"
    local answer

    if [[ -n "$default" ]]; then
        read -r -p "  Answer [$default]: " answer </dev/tty
    else
        read -r -p "  Answer: " answer </dev/tty
    fi

    echo "${answer:-$default}"
}

collect_multiline_list() {
    # AIDEV-NOTE: Collects list items, auto-prefixes with '- '
    local -a lines=()
    local line

    echo "  Enter list items (one per line, empty line to finish):" >/dev/tty

    while true; do
        read -r -p "  " line </dev/tty

        if [[ -z "$line" ]]; then
            break
        fi

        # Auto-prefix with bullet if not already present
        if [[ ! "$line" =~ ^[-*][[:space:]] ]]; then
            line="- $line"
        fi

        lines+=("$line")
    done

    printf '%s\n' "${lines[@]}"
}

collect_multiline_text() {
    # AIDEV-NOTE: Collects free-form multiline text
    local -a lines=()
    local line

    echo "  Enter text (empty line to finish):" >/dev/tty

    while true; do
        read -r line </dev/tty

        if [[ -z "$line" ]]; then
            break
        fi

        lines+=("$line")
    done

    printf '%s\n' "${lines[@]}"
}

# ============================================================
# Answers File Generation
# ============================================================

format_answer_block() {
    # AIDEV-NOTE: Formats answer in YAML literal block syntax
    local id="$1"
    local response="$2"

    echo "{{ANSWER: $id"
    echo "  user_response: |"

    # Indent each line by 4 spaces
    while IFS= read -r line; do
        echo "    $line"
    done <<< "$response"

    echo "}}"
}

generate_answers_file() {
    local template_name="$1"
    shift
    local -a answer_ids=("$@")
    local output_path="$OUTPUT_DIR/${template_name}.answers.md"

    ensure_output_dir

    {
        echo "# Template Answers"
        echo ""
        echo "<!-- Generated by Agent AgentKit -->"
        echo "<!-- Use these answers with the template to generate your agent file -->"
        echo ""

        for id in "${answer_ids[@]}"; do
            local answer_var="ANSWER_${id}"
            format_answer_block "$id" "${!answer_var}"
            echo ""
        done
    } > "$output_path"

    echo "$output_path"
}
