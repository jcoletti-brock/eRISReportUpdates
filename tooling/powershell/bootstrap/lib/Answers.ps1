#
# Answers.ps1 - Interactive Answer Collection
#
# Handles interactive prompting, answer collection, and answers file generation.
#

# Dot-source Templates module for color functions
. "$PSScriptRoot\Templates.ps1"

# ============================================================
# Interactive Answer Collection
# ============================================================

function Read-Answer {
    # AIDEV-NOTE: Prompts user for answer based on format type
    param(
        [Parameter(Mandatory)]
        [PSCustomObject]$Prompt
    )

    Write-HeaderText "Question: $($Prompt.Question)"

    if ($Prompt.Hint) {
        Write-HintText "  Hint: $($Prompt.Hint)"
    }

    if ($Prompt.Default) {
        Write-ColorText -Color 'Blue' -Message "  Default: $($Prompt.Default)"
    }

    $answer = switch ($Prompt.Format) {
        'markdown-list' {
            Read-MultilineList
        }
        { $_ -in @('multiline', 'code-block') } {
            Read-MultilineText
        }
        default {
            Read-SingleLine -Default $Prompt.Default
        }
    }

    # Use default if answer is empty
    if ([string]::IsNullOrWhiteSpace($answer) -and $Prompt.Default) {
        # Unescape \n to actual newlines
        $answer = $Prompt.Default -replace '\\n', "`n"
    }

    return $answer
}

function Read-SingleLine {
    param(
        [string]$Default = ""
    )

    if ($Default) {
        $answer = Read-Host "  Answer [$Default]"
    } else {
        $answer = Read-Host "  Answer"
    }

    if ([string]::IsNullOrWhiteSpace($answer)) {
        return $Default
    }

    return $answer
}

function Read-MultilineList {
    # AIDEV-NOTE: Collects list items, auto-prefixes with '- '
    Write-Host "  Enter list items (one per line, empty line to finish):"

    $lines = @()

    while ($true) {
        $line = Read-Host "  "

        if ([string]::IsNullOrWhiteSpace($line)) {
            break
        }

        # Auto-prefix with bullet if not already present
        if ($line -notmatch '^[-*]\s') {
            $line = "- $line"
        }

        $lines += $line
    }

    return $lines -join "`n"
}

function Read-MultilineText {
    # AIDEV-NOTE: Collects free-form multiline text
    Write-Host "  Enter text (empty line to finish):"

    $lines = @()

    while ($true) {
        $line = Read-Host "  "

        if ([string]::IsNullOrWhiteSpace($line)) {
            break
        }

        $lines += $line
    }

    return $lines -join "`n"
}

# ============================================================
# Answers File Generation
# ============================================================

function New-AnswerBlock {
    # AIDEV-NOTE: Formats answer in YAML literal block syntax
    param(
        [Parameter(Mandatory)]
        [string]$Id,

        [Parameter(Mandatory)]
        [AllowEmptyString()]
        [string]$Response
    )

    $lines = @()
    $lines += "{{ANSWER: $Id"
    $lines += "  user_response: |"

    # Indent each line by 4 spaces
    $responseLines = $Response -split "`n"
    foreach ($line in $responseLines) {
        $lines += "    $line"
    }

    $lines += "}}"

    return $lines -join "`n"
}

function New-AnswersFile {
    param(
        [Parameter(Mandatory)]
        [string]$TemplateName,

        [Parameter(Mandatory)]
        [hashtable]$Answers,

        [Parameter(Mandatory)]
        [string]$OutputDirectory
    )

    $outputPath = Join-Path $OutputDirectory "${TemplateName}.answers.md"

    # Ensure output directory exists
    if (-not (Test-Path $OutputDirectory)) {
        New-Item -Path $OutputDirectory -ItemType Directory -Force | Out-Null
    }

    $content = @()
    $content += "# Template Answers"
    $content += ""
    $content += "<!-- Generated by AgentKit -->"
    $content += "<!-- Use these answers with the template to generate your agent file -->"
    $content += ""

    foreach ($id in $Answers.Keys) {
        $content += New-AnswerBlock -Id $id -Response $Answers[$id]
        $content += ""
    }

    $content -join "`n" | Set-Content -Path $outputPath -NoNewline

    return $outputPath
}
